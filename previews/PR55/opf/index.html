<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimal Power Flow · PandaModels</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://e2nIEE.github.io/PandaModels.jl/stable/opf/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PandaModels</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickguide/">Getting Started</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Optimal Power Flow</a></li><li><a class="tocitem" href="../ots/">Optimal Transmission Switching</a></li><li><a class="tocitem" href="../tnep/">Transmission Network Expansion Planning</a></li><li><a class="tocitem" href="../vd/">Optimal Voltage Deviation</a></li></ul></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../develop/">Develop Mode</a></li><li><a class="tocitem" href="../test/">Add Test</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/e2nIEE/PandaModels.jl/blob/master/docs/src/opf.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Run-Optimal-Power-Flow"><a class="docs-heading-anchor" href="#Run-Optimal-Power-Flow">Run Optimal Power Flow</a><a id="Run-Optimal-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Run-Optimal-Power-Flow" title="Permalink"></a></h1><p>pandapower now has an interface to <a href="https://lanl-ansi.github.io/PowerModels.jl/stable/">PowerModels.jl</a> that can be used for efficient power system optimization.</p><h3 id="What-is-PowerModels.jl-and-why-should-I-use-it?"><a class="docs-heading-anchor" href="#What-is-PowerModels.jl-and-why-should-I-use-it?">What is PowerModels.jl and why should I use it?</a><a id="What-is-PowerModels.jl-and-why-should-I-use-it?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-PowerModels.jl-and-why-should-I-use-it?" title="Permalink"></a></h3><ul><li><a href="https://lanl-ansi.github.io/PowerModels.jl/stable/">PowerModels.jl</a> is  a package for steady-state power network optimization</li><li>It is based on the relatively new language <a href="https://julialang.org/">Julia</a> which is gaining popularity in scientific applications</li><li><a href="https://lanl-ansi.github.io/PowerModels.jl/stable/">PowerModels.jl</a> uses Julia/JuMP for the optimization, which <a href="http://yetanothermathprogrammingconsultant.blogspot.com/2015/05/model-generation-in-julia.html">clearly outperforms the Python alternative Pyomo</a></li><li>PowerModels has a great modular design that allows you to define <a href="https://lanl-ansi.github.io/PowerModels.jl/stable/specifications/">different formulations for optimization problems</a> based on different <a href="https://lanl-ansi.github.io/PowerModels.jl/stable/formulations/">network formulations</a> as well as use several <a href="https://lanl-ansi.github.io/PowerModels.jl/stable/relaxations/">relaxation schemes</a>. You can then solve the problem using many open source as well as commercial solvers through <a href="http://www.juliaopt.org/JuMP.jl/0.18/installation.html#getting-solvers">JuMP</a></li></ul><h3 id="Well-then-why-do-I-still-need-pandapower?"><a class="docs-heading-anchor" href="#Well-then-why-do-I-still-need-pandapower?">Well then why do I still need pandapower?</a><a id="Well-then-why-do-I-still-need-pandapower?-1"></a><a class="docs-heading-anchor-permalink" href="#Well-then-why-do-I-still-need-pandapower?" title="Permalink"></a></h3><p>Because <a href="https://pandapower.readthedocs.io/en/latest/index.html">pandapower</a>:</p><ul><li>allows you to easily define power systems with nameplate parameters and standard types</li><li>comes with thoroughly validated element models of transformers with tap changers, three-winding transformers, switches/breakers, extended ward equivalents and many more    </li><li>keeps all data in tables (<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html">pandas DataFrames</a>), which makes data management and analysis very comfortable</li><li>provides different power system analysis functions, such as a (very fast) power flow, short-circuit calculation, state estimation, graph searches and a plotting library that can be used on the same grid models</li><li>allows you to do all pre- and postprocessing in Python, which still has a much richer environment of free libraries than Julia (currently 157,755 packages on PyPI vs. 1,906 libraries on Pkg)</li></ul><p>So using <a href="https://pandapower.readthedocs.io/en/latest/index.html">pandapower</a> to define the grid models and then using <a href="https://lanl-ansi.github.io/PowerModels.jl/stable/">PowerModels.jl</a> for the optimization really gives you the best of all worlds - you can use the rich environment of Python libraries, the sophisticated element models of <a href="https://pandapower.readthedocs.io/en/latest/index.html">pandapower</a>, the modular optimization framework of <a href="https://lanl-ansi.github.io/PowerModels.jl/stable/">PowerModels.jl</a> and the efficient mathematical modeling of JuMP.</p><h3 id="Let&#39;s-get-started"><a class="docs-heading-anchor" href="#Let&#39;s-get-started">Let&#39;s get started</a><a id="Let&#39;s-get-started-1"></a><a class="docs-heading-anchor-permalink" href="#Let&#39;s-get-started" title="Permalink"></a></h3><p>So here is an example of how it works. First, we create a grid in pandapower. Here, we create a meshed 110kV grid with four buses that is fed from an 220kV network through a 3-Winding transformer.</p><pre><code class="language-python hljs">import pandapower as pp
import numpy as np
net = pp.create_empty_network()

min_vm_pu = 0.95
max_vm_pu = 1.05

#create buses
bus1 = pp.create_bus(net, vn_kv=220., geodata=(5,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)
bus2 = pp.create_bus(net, vn_kv=110., geodata=(6,10), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)
bus3 = pp.create_bus(net, vn_kv=110., geodata=(10,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)
bus4 = pp.create_bus(net, vn_kv=110., geodata=(8,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)
bus5 = pp.create_bus(net, vn_kv=110., geodata=(6,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)

#create 220/110/110 kV 3W-transformer
pp.create_transformer3w_from_parameters(net, bus1, bus2, bus5, vn_hv_kv=220, vn_mv_kv=110,
                                        vn_lv_kv=110, vk_hv_percent=10., vk_mv_percent=10.,
                                        vk_lv_percent=10., vkr_hv_percent=0.5,
                                        vkr_mv_percent=0.5, vkr_lv_percent=0.5, pfe_kw=10,
                                        i0_percent=0.1, shift_mv_degree=0, shift_lv_degree=0,
                                        sn_hv_mva=100, sn_mv_mva=50, sn_lv_mva=50)

#create 110 kV lines
l1 = pp.create_line(net, bus2, bus3, length_km=70., std_type=&#39;149-AL1/24-ST1A 110.0&#39;)
l2 = pp.create_line(net, bus3, bus4, length_km=50., std_type=&#39;149-AL1/24-ST1A 110.0&#39;)
l3 = pp.create_line(net, bus4, bus2, length_km=40., std_type=&#39;149-AL1/24-ST1A 110.0&#39;)
l4 = pp.create_line(net, bus4, bus5, length_km=30., std_type=&#39;149-AL1/24-ST1A 110.0&#39;)

#create loads
pp.create_load(net, bus2, p_mw=60)
pp.create_load(net, bus3, p_mw=70)
pp.create_load(net, bus4, p_mw=10)

#create generators
g1 = pp.create_gen(net, bus1, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01, slack=True)
pp.create_poly_cost(net, g1, &#39;gen&#39;, cp1_eur_per_mw=1)

g2 = pp.create_gen(net, bus3, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01)
pp.create_poly_cost(net, g2, &#39;gen&#39;, cp1_eur_per_mw=3)

g3 = pp.create_gen(net, bus4, p_mw=50, min_p_mw=0, max_p_mw=200, vm_pu=1.01)
pp.create_poly_cost(net, g3, &#39;gen&#39;, cp1_eur_per_mw=3)
net</code></pre><p>This pandapower network includes the following parameter tables:        - bus (5 elements)        - load (3 elements)        - gen (3 elements)        - line (4 elements)        - trafo3w (1 element)        - poly<em>cost (3 elements)        - bus</em>geodata (5 elements)</p><p>Note that PowerModels does not have a 3W-transformer model, but since pandapower includes the equations to calculates the equivalent branches for the 3W-transformers, it is possible to optimize grids with 3W-transformers in PowerModels through the pandapower interface. The same is true for other complex transformer models, switches/breaker, extended ward equivalents etc.</p><p>Let&#39;s have a look at the grid we created with pandapowers plotting module:</p><pre><code class="language-python hljs">import pandapower.plotting as plot
%matplotlib inline
plot.simple_plot(net)</code></pre><p><img src="../assets/output_5_0.png" alt="png"/></p><p>Now lets run an OPF through PowerModels and look at the results (Note that the first time the runpm function is called, Julia is started in the background, which may take some time):</p><pre><code class="language-python hljs">pp.runpm_ac_opf(net)</code></pre><p>Since Generator 1 has the lowest cost, all required power is supplied through this generator:</p><pre><code class="language-python hljs">net.res_gen</code></pre><table><tr><th style="text-align: center"><strong>gen</strong></th><th style="text-align: center"><strong>p_mw</strong></th><th style="text-align: center"><strong>q_mvar</strong></th><th style="text-align: center"><strong>va_degree</strong></th><th style="text-align: center"><strong>vm_pu</strong></th></tr><tr><td style="text-align: center">0</td><td style="text-align: center">1.448510e+02</td><td style="text-align: center">11.037217</td><td style="text-align: center">-1.390779e-28</td><td style="text-align: center">1.050000</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">-1.000000e-08</td><td style="text-align: center">6.055925</td><td style="text-align: center">-1.680643e+01</td><td style="text-align: center">1.013179</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">-1.000000e-08</td><td style="text-align: center">13.126070</td><td style="text-align: center">-1.298596e+01</td><td style="text-align: center">1.040498</td></tr></table><p>This however leeds to an overload in the three-winding transformer, through which g1 is connected:</p><pre><code class="language-python hljs">net.res_trafo3w.loading_percent</code></pre><pre><code class="nohighlight hljs">0    190.835372
Name: loading_percent, dtype: float64</code></pre><p>Let&#39;s set some constraints for the 3W-transformer and the lines and rerun the OPF:</p><pre><code class="language-python hljs">net.trafo3w[&quot;max_loading_percent&quot;] = 50
net.line[&quot;max_loading_percent&quot;] = 20
pp.runpm_ac_opf(net)</code></pre><p>The constraints are complied with for all lines and the 3W transformer:</p><pre><code class="language-python hljs">net.res_trafo3w.loading_percent</code></pre><pre><code class="nohighlight hljs">0    49.974771
Name: loading_percent, dtype: float64</code></pre><pre><code class="language-python hljs">net.res_line.loading_percent</code></pre><pre><code class="nohighlight hljs">0    19.047619
1    12.295419
2    19.207577
3     7.088596
Name: loading_percent, dtype: float64</code></pre><p>The power is now generated by a mixture of the generators:</p><pre><code class="language-python hljs">net.res_gen</code></pre><table><tr><th style="text-align: center"><strong>gen</strong></th><th style="text-align: center"><strong>p_mw</strong></th><th style="text-align: center"><strong>q_mvar</strong></th><th style="text-align: center"><strong>va_degree</strong></th><th style="text-align: center"><strong>vm_pu</strong></th></tr><tr><td style="text-align: center">0</td><td style="text-align: center">24.531626</td><td style="text-align: center">-6.267019</td><td style="text-align: center">1.836953e-27</td><td style="text-align: center">1.031058</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">98.101643</td><td style="text-align: center">-7.928710</td><td style="text-align: center">-3.576364e-01</td><td style="text-align: center">1.050000</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">18.054898</td><td style="text-align: center">9.928333</td><td style="text-align: center">-1.446870e+00</td><td style="text-align: center">1.048757</td></tr></table><p>In order to use different models, please check <a href="@ref">Getting Started</a>.</p><h3 id="Timings"><a class="docs-heading-anchor" href="#Timings">Timings</a><a id="Timings-1"></a><a class="docs-heading-anchor-permalink" href="#Timings" title="Permalink"></a></h3><p>Comparing the runopp function (that runs an OPF through PYPOWER) and the runpm function shows that PowerModels is much more performant:</p><pre><code class="language-python hljs">%timeit pp.runopp(net)</code></pre><pre><code class="nohighlight hljs">1.22 s ± 14.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre><pre><code class="language-python hljs">%timeit pp.runpm_ac_opf(net)</code></pre><pre><code class="nohighlight hljs">221 ms ± 7.18 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickguide/">« Getting Started</a><a class="docs-footer-nextpage" href="../ots/">Optimal Transmission Switching »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 12 November 2021 18:42">Friday 12 November 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
